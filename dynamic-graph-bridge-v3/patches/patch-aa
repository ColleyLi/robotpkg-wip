mirror changes in source @ Jun29 2016

diff --git CMakeLists.txt CMakeLists.txt
index a863658..cc8407e 100644
--- CMakeLists.txt
+++ CMakeLists.txt
@@ -42,6 +42,7 @@ set(CUSTOM_HEADER_DIR dynamic_graph_bridge)
 set(${PROJECT_NAME}_HEADERS
   include/dynamic_graph_bridge/ros_init.hh
   include/dynamic_graph_bridge/ros_interpreter.hh
+  include/dynamic_graph_bridge/sot_loader.hh
   )
 SEARCH_FOR_EIGEN()
 SEARCH_FOR_BOOST()
@@ -59,6 +60,7 @@ set(PKG_CONFIG_ADDITIONAL_VARIABLES
   )
 
 add_required_dependency(roscpp)
+add_required_dependency(tf)
 add_required_dependency("realtime_tools >= 1.8")
 add_required_dependency(bullet)
 ADD_REQUIRED_DEPENDENCY("pinocchio")
@@ -87,6 +89,9 @@ pkg_config_use_dependency(ros_bridge bullet)
 pkg_config_use_dependency(ros_bridge dynamic_graph_bridge_msgs)
 install(TARGETS ros_bridge DESTINATION lib)
 
+# Add ros_bridge in the dynamic-graph-bridge pkg-config file.
+
+
 # Make sure rpath are preserved during the install as ROS dependencies
 # are not installed.
 set_target_properties(ros_bridge PROPERTIES BUILD_WITH_INSTALL_RPATH True
@@ -95,9 +100,7 @@ set_target_properties(ros_bridge PROPERTIES BUILD_WITH_INSTALL_RPATH True
 macro(compile_plugin NAME)
   message(lib path ${LIBRARY_OUTPUT_PATH})
   file(MAKE_DIRECTORY "${LIBRARY_OUTPUT_PATH}/dynamic_graph/ros/${NAME}")
-  add_library(${NAME} src/${NAME}.cpp src/${NAME}.hh)
-  #pkg_config_use_dependency(${NAME} jrl-mal)
-  #kg_config_use_dependency(${NAME} eigen3)
+  add_library(${NAME} SHARED src/${NAME}.cpp src/${NAME}.hh)
   pkg_config_use_dependency(${NAME} dynamic-graph)
   pkg_config_use_dependency(${NAME} sot-core)
   #pkg_config_use_dependency(${NAME} jrl-dynamics-urdf)
@@ -105,7 +108,8 @@ macro(compile_plugin NAME)
   add_dependencies(${NAME} ros_bridge)
   target_link_libraries(${NAME} ros_bridge)
   set_target_properties(${NAME} PROPERTIES BUILD_WITH_INSTALL_RPATH True)
-  install(TARGETS ${NAME} DESTINATION lib)
+  set_target_properties(${NAME} PROPERTIES PREFIX "")
+  install(TARGETS ${NAME} DESTINATION lib/plugin)
   
 
   dynamic_graph_python_module("ros/${NAME}"
@@ -161,15 +165,24 @@ pkg_config_use_dependency(interpreter dynamic_graph_bridge_msgs)
 
 # Stand alone embedded intepreter with a robot controller.
 add_executable(geometric_simu src/geometric_simu.cpp src/sot_loader.cpp)
-pkg_config_use_dependency(geometric_simu roscpp)
-target_link_libraries(geometric_simu  ros_bridge ${Boost_LIBRARIES} dl tf)
+pkg_config_use_dependency(geometric_simu roscpp tf)
+target_link_libraries(geometric_simu ros_bridge tf ${Boost_LIBRARIES} ${CMAKE_DL_LIBS})
+
+# Sot loader library
+add_library(sot_loader src/sot_loader.cpp)
+pkg_config_use_dependency(sot_loader dynamic-graph)
+pkg_config_use_dependency(sot_loader sot-core)
+target_link_libraries(sot_loader ${Boost_LIBRARIES})
+install(TARGETS sot_loader DESTINATION lib)
 
 add_subdirectory(src)
 
 # Deal with the ROS part.
 add_service_files( FILES RunPythonFile.srv )
 generate_messages( DEPENDENCIES std_msgs )
-catkin_package(CATKIN_DEPENDS message_runtime )
+catkin_package(CATKIN_DEPENDS message_runtime LIBRARIES ros_bridge ros_interpreter)
+# Add libraries in pc file generated by cmake submodule
+PKG_CONFIG_APPEND_LIBS(ros_bridge ros_interpreter)
 
 #install ros executables
 install(PROGRAMS
diff --git include/dynamic_graph_bridge/sot_loader.hh include/dynamic_graph_bridge/sot_loader.hh
new file mode 100644
index 0000000..fe5b5b7
--- /dev/null
+++ include/dynamic_graph_bridge/sot_loader.hh
@@ -0,0 +1,163 @@
+/*
+ * Copyright 2011,
+ * Olivier Stasse,
+ *
+ * CNRS
+ *
+ * This file is part of sot-core.
+ * sot-core is free software: you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation, either version 3 of
+ * the License, or (at your option) any later version.
+ * sot-core is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.  You should
+ * have received a copy of the GNU Lesser General Public License along
+ * with sot-core.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/* -------------------------------------------------------------------------- */
+/* --- INCLUDES ------------------------------------------------------------- */
+/* -------------------------------------------------------------------------- */
+
+// System includes
+#include <iostream>
+#include <cassert>
+
+// STL includes
+#include <map>
+
+// Boost includes
+#include <boost/program_options.hpp>
+#include <boost/foreach.hpp>
+#include <boost/format.hpp>
+
+// ROS includes
+#include "ros/ros.h"
+#include "std_srvs/Empty.h"
+#include <sensor_msgs/JointState.h>
+#include <tf/transform_broadcaster.h>
+
+// Sot Framework includes 
+#include <sot/core/debug.hh>
+#include <sot/core/abstract-sot-external-interface.hh>
+
+namespace po = boost::program_options;
+namespace dgs = dynamicgraph::sot;
+
+
+class SotLoader {
+
+protected:
+
+  // Dynamic graph is stopped.
+  bool dynamic_graph_stopped_;
+
+  /// \brief the sot-hrp2 controller
+  dgs::AbstractSotExternalInterface * sotController_;
+
+  po::variables_map vm_;
+  std::string dynamicLibraryName_;
+
+  /// Map of sensor readings
+  std::map <std::string,dgs::SensorValues> sensorsIn_;
+  /// Map of control values
+  std::map<std::string,dgs::ControlValues> controlValues_;
+
+  /// Angular values read by encoders
+  std::vector <double> angleEncoder_;
+  /// Angular values sent to motors
+  std::vector<double> angleControl_;
+  /// Forces read by force sensors
+  std::vector<double> forces_;
+  /// Torques
+  std::vector<double> torques_;
+  /// Attitude of the robot computed by extended Kalman filter.
+  std::vector<double> baseAtt_;
+  /// Accelerations read by Accelerometers
+  std::vector <double> accelerometer_;
+  /// Angular velocity read by gyrometers
+  std::vector <double> gyrometer_;
+
+  /// URDF string description of the robot.
+  std::string robot_desc_string_;
+  
+  /// \brief Map between SoT state vector and some joint_state_links
+  XmlRpc::XmlRpcValue stateVectorMap_;
+
+  /// \brief List of parallel joints from the state vector.
+  typedef std::vector<int> parallel_joints_to_state_vector_t;
+  parallel_joints_to_state_vector_t parallel_joints_to_state_vector_;
+
+  /// \brief Coefficient between parallel joints and the state vector.
+  std::vector<double> coefficient_parallel_joints_;
+
+  // Joint state publication.
+  ros::Publisher joint_pub_;
+  
+  // Joint state to be published.
+  sensor_msgs::JointState joint_state_;
+
+  // \brief Start control loop
+  virtual void startControlLoop();
+
+  // Number of DOFs according to KDL.
+  int nbOfJoints_;
+  parallel_joints_to_state_vector_t::size_type nbOfParallelJoints_;
+
+  //Robot Pose Publisher
+  tf::TransformBroadcaster freeFlyerPublisher_;
+  tf::Transform freeFlyerPose_;
+
+
+public:
+  SotLoader();
+  ~SotLoader() {};
+
+  // \brief Read user input to extract the path of the SoT dynamic library.
+  int parseOptions(int argc, char *argv[]);
+
+  // \brief Load the SoT
+  void Initialization();
+
+  // \brief Create a thread for ROS.
+  void initializeRosNode(int argc, char *argv[]);
+
+  // \brief Compute one iteration of control.
+  // Basically calls fillSensors, the SoT and the readControl.
+  void oneIteration();
+
+  // \brief Fill the sensors value for the SoT.
+  void fillSensors(std::map<std::string, 
+                   dgs::SensorValues> & sensorsIn);
+
+  // \brief Read the control computed by the SoT framework.
+  void readControl(std::map<std::string, 
+                   dgs::ControlValues> & controlValues);
+
+  // \brief Prepare the SoT framework.
+  void setup();
+
+  // \brief Callback function when starting dynamic graph.
+  bool start_dg(std_srvs::Empty::Request& request, 
+                std_srvs::Empty::Response& response);
+
+  // \brief Callback function when stopping dynamic graph.
+  bool stop_dg(std_srvs::Empty::Request& request, 
+                std_srvs::Empty::Response& response);
+
+  // \brief Read the state vector description based upon the robot links.
+  int readSotVectorStateParam();
+
+  // \brief Init publication of joint states.
+  int initPublication();
+
+  // \brief Get Status of dg.
+  bool isDynamicGraphStopped()
+  { return dynamic_graph_stopped_; }
+
+  // \brief Specify the name of the dynamic library.
+  void setDynamicLibraryName(std::string &afilename);
+
+};
+
diff --git package.xml package.xml
index a7d9331..85ba68e 100644
--- package.xml
+++ package.xml
@@ -13,10 +13,6 @@
   <url>http://ros.org/wiki/dynamic_graph_bridge</url>
 
   <export>
-    <cpp
-       cflags="-I${prefix}/include"
-       lflags="-L${prefix}/lib -lros_bridge -lros_interpreter -Wl,-rpath,${prefix}/lib"
-       />
     <rosdoc config="rosdoc.yaml" />
   </export>
 
diff --git src/converter.hh src/converter.hh
index 79282ba..d3d910a 100644
--- src/converter.hh
+++ src/converter.hh
@@ -117,8 +117,8 @@ namespace dynamicgraph
   
   ROS_TO_SOT_IMPL(Matrix)
   {
-    //TODO: Confirm Ros Matrix Storage order.
-    dst.resize (src.width, src.data.size () / src.width);
+    dst.resize (src.width, (unsigned int) src.data.size () / 
+		(unsigned int)src.width);
     for (unsigned i = 0; i < src.data.size (); ++i)
       dst.data()[i] =  src.data[i];
   }
@@ -126,6 +126,7 @@ namespace dynamicgraph
   // Homogeneous matrix.
   SOT_TO_ROS_IMPL(sot::MatrixHomogeneous)
   {
+
     sot::VectorQuaternion q(src.linear());
     dst.translation.x = src.translation()(0);
     dst.translation.y = src.translation()(1);
@@ -135,6 +136,7 @@ namespace dynamicgraph
     dst.rotation.y = q.y();
     dst.rotation.z = q.z();
     dst.rotation.w = q.w();
+
   }
 
   ROS_TO_SOT_IMPL(sot::MatrixHomogeneous)
@@ -297,8 +299,9 @@ namespace dynamicgraph
     static ptime timeStart(date(1970,1,1));
     time_duration diff = time - timeStart;
 
-    uint32_t sec = diff.ticks ()/time_duration::rep_type::res_adjust ();
-    uint32_t nsec = diff.fractional_seconds();
+    uint32_t sec = (unsigned int)diff.ticks ()/
+      (unsigned int)time_duration::rep_type::res_adjust ();
+    uint32_t nsec = (unsigned int)diff.fractional_seconds();
 
     return ros::Time (sec, nsec);
   }
diff --git src/geometric_simu.cpp src/geometric_simu.cpp
index 5a6a1ff..e622377 100644
--- src/geometric_simu.cpp
+++ src/geometric_simu.cpp
@@ -20,28 +20,7 @@
 #include <boost/thread/thread.hpp>
 #include <boost/thread/condition.hpp>
 
-#include "sot_loader.hh"
-
-boost::condition_variable cond;
-boost::mutex mut;
-
-void workThread(SotLoader *aSotLoader)
-{
-  {
-    boost::lock_guard<boost::mutex> lock(mut);
-  }
-  while(aSotLoader->isDynamicGraphStopped())
-    {
-      usleep(5000);
-    }  
-  while(!aSotLoader->isDynamicGraphStopped())
-    {
-      aSotLoader->oneIteration();
-      usleep(5000);
-    }
-  cond.notify_all();
-  ros::waitForShutdown();
-}
+#include <dynamic_graph_bridge/sot_loader.hh>
 
 
 int main(int argc, char *argv[])
@@ -50,13 +29,11 @@ int main(int argc, char *argv[])
   SotLoader aSotLoader;
   if (aSotLoader.parseOptions(argc,argv)<0)
     return -1;
-  ros::NodeHandle n;
-  ros::ServiceServer service = n.advertiseService("start_dynamic_graph", 
-                                                  &SotLoader::start_dg,
-						  &aSotLoader);
-  ROS_INFO("Ready to start dynamic graph.");
-  boost::thread thr(workThread,&aSotLoader);
-  boost::unique_lock<boost::mutex> lock(mut);
-  cond.wait(lock);
-  ros::spin();
+  
+  aSotLoader.initializeRosNode(argc,argv);
+
+  while(true){
+    usleep(5000);
+  }
+ 
 }
diff --git src/ros_joint_state.cpp src/ros_joint_state.cpp
index df04d8c..c12655b 100644
--- src/ros_joint_state.cpp
+++ src/ros_joint_state.cpp
@@ -165,7 +165,7 @@ namespace dynamicgraph
 	// Fill position.
 	jointState_.position.resize (s);
 	for (std::size_t i = 0; i < s; ++i)
-	  jointState_.position[i] = state_.access (t) (i);
+	  jointState_.position[i] = state_.access (t) ((unsigned int)i);
 
 	publisher_.msg_ = jointState_;
 	publisher_.unlockAndPublish ();
diff --git src/ros_publish.hxx src/ros_publish.hxx
index deff4cf..4ff1d01 100644
--- src/ros_publish.hxx
+++ src/ros_publish.hxx
@@ -56,7 +56,6 @@ namespace dynamicgraph
   template <typename T>
   void RosPublish::add (const std::string& signal, const std::string& topic)
   {
-    typedef typename SotToRos<T>::sot_t sot_t;
     typedef typename SotToRos<T>::ros_t ros_t;
     typedef typename SotToRos<T>::signalIn_t signal_t;
 
diff --git src/ros_time.cpp src/ros_time.cpp
index 50a2367..0d50559 100644
--- src/ros_time.cpp
+++ src/ros_time.cpp
@@ -32,7 +32,7 @@ namespace dynamicgraph {
   }
 
   ptime&
-  RosTime::update (ptime& time, const int& t)
+  RosTime::update (ptime& time, const int& )
   {
     time = rosTimeToPtime (ros::Time::now ());
     return time;
diff --git src/sot_loader.cpp src/sot_loader.cpp
index 10706aa..a850624 100644
--- src/sot_loader.cpp
+++ src/sot_loader.cpp
@@ -20,15 +20,55 @@
 /* --- INCLUDES ------------------------------------------------------------- */
 /* -------------------------------------------------------------------------- */
 
-#include "sot_loader.hh"
+#include <dynamic_graph_bridge/sot_loader.hh>
+#include "dynamic_graph_bridge/ros_init.hh"
 
 // POSIX.1-2001
 #include <dlfcn.h>
 
+#include <boost/thread/thread.hpp>
+#include <boost/thread/condition.hpp>
+
+boost::condition_variable cond;
+boost::mutex mut;
+
 using namespace std;
 using namespace dynamicgraph::sot; 
 namespace po = boost::program_options;
 
+void createRosSpin(SotLoader *aSotLoader)
+{
+  ROS_INFO("createRosSpin started\n");
+  ros::NodeHandle n;
+
+  ros::ServiceServer service = n.advertiseService("start_dynamic_graph",
+                                                  &SotLoader::start_dg,
+                                                  aSotLoader);
+
+  ros::ServiceServer service2 = n.advertiseService("stop_dynamic_graph",
+                                                  &SotLoader::stop_dg,
+                                                  aSotLoader);
+
+
+  ros::waitForShutdown();
+}
+
+void workThreadLoader(SotLoader *aSotLoader)
+{
+  while(aSotLoader->isDynamicGraphStopped())
+    {
+      usleep(5000);
+    }
+
+  while(!aSotLoader->isDynamicGraphStopped())
+    {
+      aSotLoader->oneIteration();
+      usleep(5000);
+    }
+  cond.notify_all();
+  ros::waitForShutdown();
+}
+
 SotLoader::SotLoader():
   dynamic_graph_stopped_(true),
   sensorsIn_ (),
@@ -47,7 +87,7 @@ SotLoader::SotLoader():
 
 int SotLoader::initPublication()
 {
-  ros::NodeHandle n;
+  ros::NodeHandle & n = dynamicgraph::rosInit(false);
 
 
   // Prepare message to be published
@@ -56,6 +96,26 @@ int SotLoader::initPublication()
   return 0;
 }
 
+void SotLoader::startControlLoop()
+{
+  boost::thread thr(workThreadLoader, this);
+}
+
+void SotLoader::initializeRosNode(int , char *[])
+{
+  ROS_INFO("Ready to start dynamic graph.");
+  boost::unique_lock<boost::mutex> lock(mut);
+  boost::thread thr2(createRosSpin,this);
+
+  startControlLoop();
+}   
+
+
+void SotLoader::setDynamicLibraryName(std::string &afilename)
+{
+  dynamicLibraryName_ = afilename;
+}
+
 int SotLoader::readSotVectorStateParam()
 {
   std::map<std::string,int> from_state_name_to_state_vector;
diff --git src/sot_loader.hh src/sot_loader.hh
deleted file mode 100644
index c57f473..0000000
--- src/sot_loader.hh
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Copyright 2011,
- * Olivier Stasse,
- *
- * CNRS
- *
- * This file is part of sot-core.
- * sot-core is free software: you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public License
- * as published by the Free Software Foundation, either version 3 of
- * the License, or (at your option) any later version.
- * sot-core is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.  You should
- * have received a copy of the GNU Lesser General Public License along
- * with sot-core.  If not, see <http://www.gnu.org/licenses/>.
- */
-/* -------------------------------------------------------------------------- */
-/* --- INCLUDES ------------------------------------------------------------- */
-/* -------------------------------------------------------------------------- */
-
-// System includes
-#include <iostream>
-#include <cassert>
-
-// STL includes
-#include <map>
-
-// Boost includes
-#include <boost/program_options.hpp>
-#include <boost/foreach.hpp>
-#include <boost/format.hpp>
-
-// ROS includes
-#include "ros/ros.h"
-#include "std_srvs/Empty.h"
-#include <sensor_msgs/JointState.h>
-#include <tf/transform_broadcaster.h>
-
-// Sot Framework includes 
-#include <sot/core/debug.hh>
-#include <sot/core/abstract-sot-external-interface.hh>
-
-namespace po = boost::program_options;
-namespace dgs = dynamicgraph::sot;
-
-
-class SotLoader {
-
-protected:
-
-  // Dynamic graph is stopped.
-  bool dynamic_graph_stopped_;
-
-  /// \brief the sot-hrp2 controller
-  dgs::AbstractSotExternalInterface * sotController_;
-
-  po::variables_map vm_;
-  std::string dynamicLibraryName_;
-
-  /// Map of sensor readings
-  std::map <std::string,dgs::SensorValues> sensorsIn_;
-  /// Map of control values
-  std::map<std::string,dgs::ControlValues> controlValues_;
-
-  /// Angular values read by encoders
-  std::vector <double> angleEncoder_;
-  /// Angular values sent to motors
-  std::vector<double> angleControl_;
-  /// Forces read by force sensors
-  std::vector<double> forces_;
-  /// Torques
-  std::vector<double> torques_;
-  /// Attitude of the robot computed by extended Kalman filter.
-  std::vector<double> baseAtt_;
-  /// Accelerations read by Accelerometers
-  std::vector <double> accelerometer_;
-  /// Angular velocity read by gyrometers
-  std::vector <double> gyrometer_;
-
-  /// URDF string description of the robot.
-  std::string robot_desc_string_;
-  
-  /// \brief Map between SoT state vector and some joint_state_links
-  XmlRpc::XmlRpcValue stateVectorMap_;
-
-  /// \brief List of parallel joints from the state vector.
-  typedef std::vector<int> parallel_joints_to_state_vector_t;
-  parallel_joints_to_state_vector_t parallel_joints_to_state_vector_;
-
-  /// \brief Coefficient between parallel joints and the state vector.
-  std::vector<double> coefficient_parallel_joints_;
-
-  // Joint state publication.
-  ros::Publisher joint_pub_;
-  
-  // Joint state to be published.
-  sensor_msgs::JointState joint_state_;
-
-  // Number of DOFs according to KDL.
-  int nbOfJoints_;
-  parallel_joints_to_state_vector_t::size_type nbOfParallelJoints_;
-
-  //Robot Pose Publisher
-  tf::TransformBroadcaster freeFlyerPublisher_;
-  tf::Transform freeFlyerPose_;
-
-
-public:
-  SotLoader();
-  ~SotLoader() {};
-
-  // \brief Read user input to extract the path of the SoT dynamic library.
-  int parseOptions(int argc, char *argv[]);
-
-  // \brief Load the SoT
-  void Initialization();
-
-  // \brief Compute one iteration of control.
-  // Basically calls fillSensors, the SoT and the readControl.
-  void oneIteration();
-
-  // \brief Fill the sensors value for the SoT.
-  void fillSensors(std::map<std::string, 
-                   dgs::SensorValues> & sensorsIn);
-
-  // \brief Read the control computed by the SoT framework.
-  void readControl(std::map<std::string, 
-                   dgs::ControlValues> & controlValues);
-
-  // \brief Prepare the SoT framework.
-  void setup();
-
-  // \brief Callback function when starting dynamic graph.
-  bool start_dg(std_srvs::Empty::Request& request, 
-                std_srvs::Empty::Response& response);
-
-  // \brief Callback function when stopping dynamic graph.
-  bool stop_dg(std_srvs::Empty::Request& request, 
-                std_srvs::Empty::Response& response);
-
-  // \brief Read the state vector description based upon the robot links.
-  int readSotVectorStateParam();
-
-  // \brief Init publication of joint states.
-  int initPublication();
-
-  // \brief Get Status of dg.
-  bool isDynamicGraphStopped()
-  { return dynamic_graph_stopped_; }
-};
-
