From 1e230fcafde3edd3ded8ece84ab56451c8718061 Mon Sep 17 00:00:00 2001
From: Guilhem Saurel <guilhem.saurel@laas.fr>
Date: Wed, 30 Sep 2020 11:04:10 +0200
Subject: [PATCH 1/2] obj_to_constraints: fix format

it was containing tabs, which were breaking robotpkg binary builds:
Sorry: TabError: inconsistent use of tabs and spaces in indentation (obj_to_constraints.py, line 37)
---
 data/com_inequalities/obj_to_constraints.py | 289 +++++++++++---------
 1 file changed, 154 insertions(+), 135 deletions(-)

diff --git a/data/com_inequalities/obj_to_constraints.py b/data/com_inequalities/obj_to_constraints.py
index f7d7997..3d8f6b2 100644
--- data/com_inequalities/obj_to_constraints.py
+++ data/com_inequalities/obj_to_constraints.py
@@ -1,156 +1,175 @@
-#do the loading of the obj file
-import numpy as np
+"""do the loading of the obj file"""
 from collections import namedtuple
+from pickle import dump, load
+
+import numpy as np
+
 ObjectData = namedtuple("ObjectData", "V T N F")
 Inequalities = namedtuple("Inequality", "A b N V")
 
+
 def toFloat(stringArray):
-	res= np.zeros(len(stringArray))
-	for i in range(0,len(stringArray)):
-		res[i] = float(stringArray[i])
-	return res
-
-def load_obj(filename) :
- V = [] #vertex
- T = [] #texcoords
- N = [] #normals
- F = [] #face indexies
-
- fh = open(filename)
- for line in fh :
-  if line[0] == '#' : continue
-
-  line = line.strip().split(' ')
-  if line[0] == 'v' : #vertex
-   V.append(toFloat(line[1:]))
-  elif line[0] == 'vt' : #tex-coord
-   T.append(line[1:])
-  elif line[0] == 'vn' : #normal vector
-   N.append(toFloat(line[1:]))
-  elif line[0] == 'f' : #face
-   face = line[1:]
-   for i in range(0, len(face)) :
-    face[i] = face[i].split('/')
-    # OBJ indexies are 1 based not 0 based hence the -1
-    # convert indexies to integer
-    for j in range(0, len(face[i])): 
-		if j!=1:
-			face[i][j] = int(face[i][j]) - 1
-   F.append(face)
-
- return ObjectData(V, T, N, F)
- 
-def inequality(v, n): 
-	#the plan has for equation ax + by + cz = d, with a b c coordinates of the normal
-	#inequality is then ax + by +cz -d <= 0 
-	# last var is v because we need it
-	return [n[0], n[1], n[2], np.array(v).dot(np.array(n))]
-	
+    res = np.zeros(len(stringArray))
+    for i in range(0, len(stringArray)):
+        res[i] = float(stringArray[i])
+    return res
+
+
+def load_obj(filename):
+    V = []  # vertex
+    T = []  # texcoords
+    N = []  # normals
+    F = []  # face indexies
+
+    fh = open(filename)
+    for line in fh:
+        if line[0] == '#':
+            continue
+
+        line = line.strip().split(' ')
+        if line[0] == 'v':  # vertex
+            V.append(toFloat(line[1:]))
+        elif line[0] == 'vt':  # tex-coord
+            T.append(line[1:])
+        elif line[0] == 'vn':  # normal vector
+            N.append(toFloat(line[1:]))
+        elif line[0] == 'f':  # face
+            face = line[1:]
+            for i in range(0, len(face)):
+                face[i] = face[i].split('/')
+                # OBJ indexies are 1 based not 0 based hence the -1
+                # convert indexies to integer
+                for j in range(0, len(face[i])):
+                    if j != 1:
+                        face[i][j] = int(face[i][j]) - 1
+            F.append(face)
+
+    return ObjectData(V, T, N, F)
+
+
+def inequality(v, n):
+    """
+    the plan has for equation ax + by + cz = d, with a b c coordinates of the normal
+    inequality is then ax + by +cz -d <= 0
+    last var is v because we need it
+    """
+    return [n[0], n[1], n[2], np.array(v).dot(np.array(n))]
+
+
 def as_inequalities(obj):
-	#for each face, find first three points and deduce plane
-	#inequality is given by normal
-	A= np.empty([len(obj.F), 3])
-	b = np.empty(len(obj.F))
-	V = np.ones([len(obj.F), 4])
-	N = np.empty([len(obj.F), 3])
-	for f in range(0, len(obj.F)):
-		face = obj.F[f]
-		v = obj.V[face[0][0]]
-		# assume normals are in obj
-		n = obj.N[face[0][2]]
-		ineq = inequality(v,n)
-		A[f,:] = ineq[0:3]
-		b[f] = ineq[3]
-		V[f,0:3] = v
-		N[f,:] = n
-	return Inequalities(A,b, N, V)
-	
+    """
+    for each face, find first three points and deduce plane
+    inequality is given by normal
+    """
+    A = np.empty([len(obj.F), 3])
+    b = np.empty(len(obj.F))
+    V = np.ones([len(obj.F), 4])
+    N = np.empty([len(obj.F), 3])
+    for f in range(0, len(obj.F)):
+        face = obj.F[f]
+        v = obj.V[face[0][0]]
+        # assume normals are in obj
+        n = obj.N[face[0][2]]
+        ineq = inequality(v, n)
+        A[f, :] = ineq[0:3]
+        b[f] = ineq[3]
+        V[f, 0:3] = v
+        N[f, :] = n
+    return Inequalities(A, b, N, V)
+
+
 def is_inside(inequalities, pt):
-	return ((inequalities.A.dot(pt) - inequalities.b) < 0).all()
+    return ((inequalities.A.dot(pt) - inequalities.b) < 0).all()
+
+
+# def rotate_inequalities_q():
 
-#~ def rotate_inequalities_q():
 
 # TODO this is naive, should be a way to simply update d
 def rotate_inequalities(ineq, transform):
-	#for each face, find first three points and deduce plane
-	#inequality is given by normal
-	A = np.empty([len(ineq.A), 3])
-	b = np.empty(len(ineq.b))
-	V = np.ones([len(ineq.V), 4])
-	N = np.ones([len(ineq.N), 3])
-	for i in range(0, len(b)):
-		v = transform.dot(ineq.V[i,:])
-		n = transform[0:3,0:3].dot(ineq.N[i,0:3])
-		ine = inequality(v[0:3],n[0:3])
-		A[i,:] = ine[0:3]
-		b[i] = ine[3]
-		V[i,:] = v
-		N[i,:] = n
-	return Inequalities(A,b, N, V)
-
-from pickle import dump
+    """
+    for each face, find first three points and deduce plane
+    inequality is given by normal
+    """
+    A = np.empty([len(ineq.A), 3])
+    b = np.empty(len(ineq.b))
+    V = np.ones([len(ineq.V), 4])
+    N = np.ones([len(ineq.N), 3])
+    for i in range(0, len(b)):
+        v = transform.dot(ineq.V[i, :])
+        n = transform[0:3, 0:3].dot(ineq.N[i, 0:3])
+        ine = inequality(v[0:3], n[0:3])
+        A[i, :] = ine[0:3]
+        b[i] = ine[3]
+        V[i, :] = v
+        N[i, :] = n
+    return Inequalities(A, b, N, V)
+
+
 def ineq_to_file(ineq, filename):
-	f1=open(filename, 'w+')
-	res = { 'A' : ineq.A, 'b' : ineq.b, 'N' : ineq.N, 'V' : ineq.V}
-	dump(res, f1)
-	f1.close()
-	
-from pickle import load
+    with open(filename, 'w+') as f1:
+        res = {'A': ineq.A, 'b': ineq.b, 'N': ineq.N, 'V': ineq.V}
+        dump(res, f1)
+
+
 def ineq_from_file(filename):
-	f1=open(filename, 'r')
-	res = load(f1)
-	return Inequalities(res['A'], res['b'],res['N'],res['V'])
-	
+    with open(filename, 'r') as f1:
+        res = load(f1)
+    return Inequalities(res['A'], res['b'], res['N'], res['V'])
+
+
 def test_inequality():
-	n = np.array([0,-1,0])
-	v = np.array([0,1,1])
-	if inequality(v,n) != [0,-1,0,-1]:
-		print("error in test_inequality")
-	else:
-		print("test_inequality successful")
+    n = np.array([0, -1, 0])
+    v = np.array([0, 1, 1])
+    if inequality(v, n) != [0, -1, 0, -1]:
+        print("error in test_inequality")
+    else:
+        print("test_inequality successful")
+
 
 def __gen_data():
-	obj = load_obj('./hrp2/RL_com._reduced.obj')
-	ineq = as_inequalities(obj)
-	ok_points = [[0,0,0], [0.0813, 0.0974, 0.2326], [-0.3387, 0.1271, -0.5354]]
-	not_ok_points = [[-0.3399, 0.2478, -0.722],[-0.1385,-0.4401,-0.1071]]
-	return obj, ineq, ok_points, not_ok_points
+    obj = load_obj('./hrp2/RL_com._reduced.obj')
+    ineq = as_inequalities(obj)
+    ok_points = [[0, 0, 0], [0.0813, 0.0974, 0.2326], [-0.3387, 0.1271, -0.5354]]
+    not_ok_points = [[-0.3399, 0.2478, -0.722], [-0.1385, -0.4401, -0.1071]]
+    return obj, ineq, ok_points, not_ok_points
+
 
 def test_belonging():
-	data = __gen_data()
-	ineq = data[1]
-	ok_points = data[2]
-	not_ok_points = data[3]
-	for p in ok_points:
-		assert (is_inside(ineq, np.array(p))), "point " + str(p) + " should be inside object"
-	for p in not_ok_points:
-		assert (not is_inside(ineq, np.array(p))), "point " + str(p) + " should NOT be inside object"
-	print("test_belonging successful")
-	
+    data = __gen_data()
+    ineq = data[1]
+    ok_points = data[2]
+    not_ok_points = data[3]
+    for p in ok_points:
+        assert (is_inside(ineq, np.array(p))), "point " + str(p) + " should be inside object"
+    for p in not_ok_points:
+        assert (not is_inside(ineq, np.array(p))), "point " + str(p) + " should NOT be inside object"
+    print("test_belonging successful")
+
+
 def test_rotate_inequalities():
-	
-	tr = np.array([[ 1.        ,  0.        ,  0.        ,  0.        ],
-				   [ 0.        ,  0.98006658, -0.19866933,  2.        ],
-				   [ 0.        ,  0.19866933,  0.98006658,  0.        ],
-				   [ 0.        ,  0.        ,  0.        ,  1.        ]])
-	
-	data = __gen_data()
-	ineq = rotate_inequalities(data[1], tr)
-	ok_points =  [tr.dot(np.array(el + [1]))[0:3] for el in data[2]]
-	not_ok_points = [tr.dot(np.array(el + [1]))[0:3] for el in data[3]]
-	for p in ok_points:
-		assert (is_inside(ineq, p)), "point " + str(p) + " should be inside object"
-	for p in not_ok_points:
-		assert (not is_inside(ineq, p)), "point " + str(p) + " should NOT be inside object"
-	print("test_rotate_inequalities successful")
-	
+
+    tr = np.array([[1., 0., 0., 0.], [0., 0.98006658, -0.19866933, 2.], [0., 0.19866933, 0.98006658, 0.],
+                   [0., 0., 0., 1.]])
+
+    data = __gen_data()
+    ineq = rotate_inequalities(data[1], tr)
+    ok_points = [tr.dot(np.array(el + [1]))[0:3] for el in data[2]]
+    not_ok_points = [tr.dot(np.array(el + [1]))[0:3] for el in data[3]]
+    for p in ok_points:
+        assert (is_inside(ineq, p)), "point " + str(p) + " should be inside object"
+    for p in not_ok_points:
+        assert (not is_inside(ineq, p)), "point " + str(p) + " should NOT be inside object"
+    print("test_rotate_inequalities successful")
+
 
 def load_obj_and_save_ineq(in_name, out_name):
-	obj = load_obj(in_name)
-	ineq = as_inequalities(obj)
-	ineq_to_file (ineq, out_name)	
-	
-load_obj_and_save_ineq('./lfleg_com_reduced.obj','./lfleg_com.ineq')
-load_obj_and_save_ineq('./lhleg_com_reduced.obj','./lhleg_com.ineq')
-load_obj_and_save_ineq('./rhleg_com_reduced.obj','./rhleg_com.ineq')
-load_obj_and_save_ineq('./rfleg_com_reduced.obj','./rfleg_com.ineq')
+    obj = load_obj(in_name)
+    ineq = as_inequalities(obj)
+    ineq_to_file(ineq, out_name)
+
+
+load_obj_and_save_ineq('./lfleg_com_reduced.obj', './lfleg_com.ineq')
+load_obj_and_save_ineq('./lhleg_com_reduced.obj', './lhleg_com.ineq')
+load_obj_and_save_ineq('./rhleg_com_reduced.obj', './rhleg_com.ineq')
+load_obj_and_save_ineq('./rfleg_com_reduced.obj', './rfleg_com.ineq')

From 37208814b7740a6b2996604d5384ae8ef307e17e Mon Sep 17 00:00:00 2001
From: Guilhem Saurel <guilhem.saurel@laas.fr>
Date: Wed, 30 Sep 2020 11:10:09 +0200
Subject: [PATCH 2/2] [Python] format

Other tabs where here and there
---
 hyq_rbprm/hyq.py                             |  11 +-
 hyq_rbprm/hyq_contact6D.py                   |  10 +-
 script/admissibleComPositionsFromEffector.py | 165 ++++++++++---------
 script/generateROMs.py                       |  70 ++++----
 script/hyq_data.py                           |  52 +++---
 5 files changed, 157 insertions(+), 151 deletions(-)

diff --git a/hyq_rbprm/hyq.py b/hyq_rbprm/hyq.py
index a7d8699..f54a3ca 100644
--- hyq_rbprm/hyq.py
+++ hyq_rbprm/hyq.py
@@ -19,11 +19,10 @@
 import numpy as np
 
 from hpp.corbaserver.rbprm.rbprmfullbody import FullBody as Parent
-from pinocchio import SE3, Quaternion
+from pinocchio import SE3
 
 
 class Robot(Parent):
-    ##
     #  Information to retrieve urdf and srdf files.
     name = "hyq"
     packageName = "example-robot-data/robots/hyq_description"
@@ -33,7 +32,7 @@ class Robot(Parent):
     urdfSuffix = "_no_sensors"
     srdfSuffix = ""
 
-    ## Information about the names of thes joints defining the limbs of the robot
+    # Information about the names of thes joints defining the limbs of the robot
     rLegId = 'rfleg'
     rleg = 'rf_haa_joint'
     rfoot = 'rf_foot_joint'
@@ -75,7 +74,7 @@ class Robot(Parent):
         0,
         0,
         0,
-        0,  #FF
+        0,  # FF
         100.,
         1.,
         20.,  # LF
@@ -113,7 +112,7 @@ class Robot(Parent):
     # size of the contact surface (x,y)
     dict_size = {rfoot: [0.02, 0.02], lfoot: [0.02, 0.02], rhand: [0.02, 0.02], lhand: [0.02, 0.02]}
     dict_normal = {rfoot: normal, lfoot: normal, rhand: normal, lhand: normal}
-    #various offset used by scripts
+    # various offset used by scripts
     MRsole_offset = SE3.Identity()
     MRsole_offset.translation = np.matrix(offset).T
     MLsole_offset = MRsole_offset.copy()
@@ -134,7 +133,7 @@ def __init__(self, name=None, load=True, client=None, clientRbprm=None):
         Parent.__init__(self, self.name, self.rootJointType, load, client, None, clientRbprm)
 
     def loadAllLimbs(self, heuristic, analysis=None, nbSamples=nbSamples, octreeSize=octreeSize):
-        if isinstance(heuristic, str):  #only one heuristic name given assign it to all the limbs
+        if isinstance(heuristic, str):  # aonly one heuristic name given assign it to all the limbs
             dict_heuristic = {}
             for id in self.limbs_names:
                 dict_heuristic.update({id: heuristic})
diff --git a/hyq_rbprm/hyq_contact6D.py b/hyq_rbprm/hyq_contact6D.py
index 2631cba..22cb777 100644
--- hyq_rbprm/hyq_contact6D.py
+++ hyq_rbprm/hyq_contact6D.py
@@ -16,13 +16,13 @@
 # hpp_tutorial.  If not, see
 # <http://www.gnu.org/licenses/>.
 
-from hpp.corbaserver.rbprm.rbprmfullbody import FullBody as Parent
-from pinocchio import SE3, Quaternion
 import numpy as np
 
+from hpp.corbaserver.rbprm.rbprmfullbody import FullBody as Parent
+from pinocchio import SE3
+
 
 class Robot(Parent):
-    ##
     #  Information to retrieve urdf and srdf files.
     name = "hyq"
     packageName = "hyq_description"
@@ -32,7 +32,7 @@ class Robot(Parent):
     urdfSuffix = "_contact6D"
     srdfSuffix = ""
 
-    ## Information about the names of thes joints defining the limbs of the robot
+    # Information about the names of thes joints defining the limbs of the robot
     rLegId = 'rfleg'
     rleg = 'rf_haa_joint'
     rfoot = 'rf_foot_Z'
@@ -100,7 +100,7 @@ class Robot(Parent):
     # size of the contact surface (x,y)
     dict_size = {rfoot: [0.04, 0.04], lfoot: [0.04, 0.04], rhand: [0.04, 0.04], lhand: [0.04, 0.04]}
 
-    #various offset used by scripts
+    # various offset used by scripts
     MRsole_offset = SE3.Identity()
     MRsole_offset.translation = np.matrix(offset).T
     MLsole_offset = MRsole_offset.copy()
diff --git a/script/admissibleComPositionsFromEffector.py b/script/admissibleComPositionsFromEffector.py
index bf4c657..0de2109 100644
--- script/admissibleComPositionsFromEffector.py
+++ script/admissibleComPositionsFromEffector.py
@@ -1,8 +1,13 @@
-#Importing helper class for RBPRM
+"""Importing helper class for RBPRM"""
+
+from __future__ import print_function
+
+import numpy as np
+
+import quaternion as quat
 from hpp.corbaserver.rbprm.rbprmbuilder import Builder
 from hpp.corbaserver.rbprm.rbprmfullbody import FullBody
 from hpp.gepetto import Viewer
-import quaternion as quat
 
 packageName = "hyq_description"
 meshPackageName = "hyq_description"
@@ -14,9 +19,9 @@
 srdfSuffix = ""
 
 #  This time we load the full body model of HyQ
-fullBody = FullBody () 
+fullBody = FullBody()
 fullBody.loadFullBodyModel(urdfName, rootJointType, meshPackageName, packageName, urdfSuffix, srdfSuffix)
-fullBody.setJointBounds ("base_joint_xyz", [-20,20, -20, 20, -20, 20])
+fullBody.setJointBounds("base_joint_xyz", [-20, 20, -20, 20, -20, 20])
 
 #  Setting a number of sample configurations used
 nbSamples = 100000
@@ -33,101 +38,103 @@
 # Last joint of the limb, as in urdf file
 rfoot = 'rf_foot_Z'
 # Specifying the distance between last joint and contact surface
-offset = [0.,-0.021,0.]
+offset = [0., -0.021, 0.]
 # Specifying the contact surface direction when the limb is in rest pose
-normal = [0,1,0]
+normal = [0, 1, 0]
 # Specifying the rectangular contact surface length
-legx = 0.02; legy = 0.02
+legx = 0.02
+legy = 0.02
 # remaining parameters are the chosen heuristic (here, manipulability), and the resolution of the octree (here, 10 cm).
-fullBody.addLimb(rLegId,rLeg,rfoot,offset,normal, legx, legy, nbSamples, "manipulability", 0.05, cType)
+fullBody.addLimb(rLegId, rLeg, rfoot, offset, normal, legx, legy, nbSamples, "manipulability", 0.05, cType)
 
 lLegId = 'lhleg'
 lLeg = 'lh_haa_joint'
 lfoot = 'lh_foot_Z'
-fullBody.addLimb(lLegId,lLeg,lfoot,offset,normal, legx, legy, nbSamples, "manipulability", 0.05, cType)
+fullBody.addLimb(lLegId, lLeg, lfoot, offset, normal, legx, legy, nbSamples, "manipulability", 0.05, cType)
 
 rarmId = 'rhleg'
 rarm = 'rh_haa_joint'
 rHand = 'rh_foot_Z'
-fullBody.addLimb(rarmId,rarm,rHand,offset,normal, legx, legy, nbSamples, "manipulability", 0.05, cType)
+fullBody.addLimb(rarmId, rarm, rHand, offset, normal, legx, legy, nbSamples, "manipulability", 0.05, cType)
 
 larmId = 'lfleg'
 larm = 'lf_haa_joint'
 lHand = 'lf_foot_Z'
-fullBody.addLimb(larmId,larm,lHand,offset,normal, legx, legy, nbSamples, "forward", 0.05, cType)
+fullBody.addLimb(larmId, larm, lHand, offset, normal, legx, legy, nbSamples, "forward", 0.05, cType)
 
-#make sure this is 0
-q_0 = fullBody.getCurrentConfig ()
-zeroConf = [0,0,0, 1, 0, 0, 0]
+# make sure this is 0
+q_0 = fullBody.getCurrentConfig()
+zeroConf = [0, 0, 0, 1, 0, 0, 0]
 q_0[0:7] = zeroConf
-fullBody.setCurrentConfig (q_0)
+fullBody.setCurrentConfig(q_0)
 
 effectors = [rfoot, lfoot, lHand, rHand]
-limbIds = [rLegId, lLegId, larmId, rarmId ]
+limbIds = [rLegId, lLegId, larmId, rarmId]
+
+# effectorName = rfoot
+# limbId = rLegId
+# q = fullBody.getSample(limbId, 1)
+# fullBody.setCurrentConfig(q) #setConfiguration matching sample
+# qEffector = fullBody.getJointPosition(effectorName)
+# q0 = quat.Quaternion(qEffector[3:7])
+# rot = q0.toRotationMatrix() #compute rotation matrix world -> local
+# p = qEffector[0:3] #(0,0,0) coordinate expressed in effector fram
+# rm=np.zeros((4,4))
+# for i in range(0,3):
+# for j in range(0,3):
+# rm[i,j] = rot[i,j]
+# for i in range(0,3):
+# rm[i,3] = qEffector[i]
+# rm[3,3] = 1
+# invrm = np.linalg.inv(rm)
+# p = invrm.dot([0,0,0,1])
+
+points = [[], [], [], []]
 
-import numpy as np
-#~ effectorName = rfoot
-#~ limbId = rLegId
-#~ q = fullBody.getSample(limbId, 1)
-#~ fullBody.setCurrentConfig(q) #setConfiguration matching sample
-#~ qEffector = fullBody.getJointPosition(effectorName)
-#~ q0 = quat.Quaternion(qEffector[3:7])
-#~ rot = q0.toRotationMatrix() #compute rotation matrix world -> local
-#~ p = qEffector[0:3] #(0,0,0) coordinate expressed in effector fram
-#~ rm=np.zeros((4,4))
-#~ for i in range(0,3):
-	#~ for j in range(0,3):
-		#~ rm[i,j] = rot[i,j]
-#~ for i in range(0,3):
-	#~ rm[i,3] = qEffector[i]
-#~ rm[3,3] = 1
-#~ invrm = np.linalg.inv(rm)
-#~ p = invrm.dot([0,0,0,1])
-
-points = [[],[],[],[]]
 
 def printComPosition(nbConfigs):
-	num_invalid = 0
-	for i in range(0,nbConfigs):
-		q = fullBody.shootRandomConfig()
-		q[0:7] = zeroConf
-		fullBody.setCurrentConfig(q) #setConfiguration matching sample
-		com = fullBody.getCenterOfMass()
-		for x in range(0,3):
-			q[x] = -com[x]
-		fullBody.setCurrentConfig(q)
-		#~ print ("final com" + str(com))
-		#~ print ("final com" + str(fullBody.getCenterOfMass()))
-		if(fullBody.isConfigValid(q)[0]):
-			for j in range(0,len(effectors)):
-				effectorName = effectors[j]
-				limbId = limbIds[j]
-				qEffector = fullBody.getJointPosition(effectorName)
-				q0 = quat.Quaternion(qEffector[3:7])
-				rot = q0.toRotationMatrix() #compute rotation matrix world -> local
-				p = qEffector[0:3] #(0,0,0) coordinate expressed in effector fram
-				rm=np.zeros((4,4))
-				for k in range(0,3):
-					for l in range(0,3):
-						rm[k,l] = rot[k,l]
-				for m in range(0,3):
-					rm[m,3] = qEffector[m]
-				rm[3,3] = 1
-				invrm = np.linalg.inv(rm)
-				p = invrm.dot([0,0,0,1])
-				points[j].append(p)
-				#~ print (points[j])
-		else:
-			num_invalid +=1
-	for j in range(0,len(limbIds)):
-		f1=open('./'+str(limbIds[j])+'_com.erom', 'w+')
-		for p in points[j]:
-			f1.write(str(p[0]) + "," + str(p[1]) + "," + str(p[2]) + "\n")
-		f1.close()
-	print "%invalid ", (float)(num_invalid) / (float)(nbConfigs) * 100, "%"
-
-#~ printRootPosition(rLegId, rfoot, nbSamples)
-#~ printRootPosition(lLegId, lfoot, nbSamples)
-#~ printRootPosition(rarmId, rHand, nbSamples)
-#~ printRootPosition(larmId, lHand, nbSamples) 
+    num_invalid = 0
+    for i in range(0, nbConfigs):
+        q = fullBody.shootRandomConfig()
+        q[0:7] = zeroConf
+        fullBody.setCurrentConfig(q)  # setConfiguration matching sample
+        com = fullBody.getCenterOfMass()
+        for x in range(0, 3):
+            q[x] = -com[x]
+        fullBody.setCurrentConfig(q)
+        # print ("final com" + str(com))
+        # print ("final com" + str(fullBody.getCenterOfMass()))
+        if (fullBody.isConfigValid(q)[0]):
+            for j in range(0, len(effectors)):
+                effectorName = effectors[j]
+                # limbId = limbIds[j]
+                qEffector = fullBody.getJointPosition(effectorName)
+                q0 = quat.Quaternion(qEffector[3:7])
+                rot = q0.toRotationMatrix()  # compute rotation matrix world -> local
+                p = qEffector[0:3]  # (0,0,0) coordinate expressed in effector fram
+                rm = np.zeros((4, 4))
+                for k in range(0, 3):
+                    for l in range(0, 3):
+                        rm[k, l] = rot[k, l]
+                for m in range(0, 3):
+                    rm[m, 3] = qEffector[m]
+                rm[3, 3] = 1
+                invrm = np.linalg.inv(rm)
+                p = invrm.dot([0, 0, 0, 1])
+                points[j].append(p)
+                # print (points[j])
+        else:
+            num_invalid += 1
+    for j in range(0, len(limbIds)):
+        f1 = open('./' + str(limbIds[j]) + '_com.erom', 'w+')
+        for p in points[j]:
+            f1.write(str(p[0]) + "," + str(p[1]) + "," + str(p[2]) + "\n")
+        f1.close()
+    print("%invalid ", (float)(num_invalid) / (float)(nbConfigs) * 100, "%")
+
+
+# printRootPosition(rLegId, rfoot, nbSamples)
+# printRootPosition(lLegId, lfoot, nbSamples)
+# printRootPosition(rarmId, rHand, nbSamples)
+# printRootPosition(larmId, lHand, nbSamples)
 printComPosition(100000)
diff --git a/script/generateROMs.py b/script/generateROMs.py
index 1b85713..1f53c39 100755
--- script/generateROMs.py
+++ script/generateROMs.py
@@ -1,75 +1,77 @@
+import quaternion as quat
+from hpp.corbaserver.rbprm.problem_solver import ProblemSolver
 from hpp.corbaserver.rbprm.rbprmbuilder import Builder
 from hpp.corbaserver.rbprm.rbprmfullbody import FullBody
 from hpp.gepetto import Viewer
 
-
-import quaternion as quat
-
 packageName = "hyq_description"
 meshPackageName = "hyq_description"
 rootJointType = "freeflyer"
-##
+#
 #  Information to retrieve urdf and srdf files.
 urdfName = "hyq"
 urdfSuffix = ""
 srdfSuffix = ""
 
-fullBody = FullBody ()
- 
-fullBody.loadFullBodyModel(urdfName, rootJointType, meshPackageName, packageName, urdfSuffix, srdfSuffix)
+fullBody = FullBody()
 
-from hpp.corbaserver.rbprm.problem_solver import ProblemSolver
+fullBody.loadFullBodyModel(urdfName, rootJointType, meshPackageName, packageName, urdfSuffix, srdfSuffix)
 
 nbSamples = 50000
 
-ps = ProblemSolver( fullBody )
+ps = ProblemSolver(fullBody)
 
 rootName = 'base_joint_xyz'
 
-#~ AFTER loading obstacles
+# AFTER loading obstacles
 rLegId = 'rfleg'
 rLeg = 'rf_haa_joint'
 rfoot = 'rf_foot_joint'
-rLegOffset = [0,0,0]
-rLegNormal = [0,1,0]
-rLegx = 0.02; rLegy = 0.02
-fullBody.addLimb(rLegId,rLeg,rfoot,rLegOffset,rLegNormal, rLegx, rLegy, nbSamples, "EFORT", 0.01)
+rLegOffset = [0, 0, 0]
+rLegNormal = [0, 1, 0]
+rLegx = 0.02
+rLegy = 0.02
+fullBody.addLimb(rLegId, rLeg, rfoot, rLegOffset, rLegNormal, rLegx, rLegy, nbSamples, "EFORT", 0.01)
 
 lLegId = 'lhleg'
 lLeg = 'lh_haa_joint'
 lfoot = 'lh_foot_joint'
-lLegOffset = [0,0,0]
-lLegNormal = [0,1,0]
-lLegx = 0.02; lLegy = 0.02
-fullBody.addLimb(lLegId,lLeg,lfoot,lLegOffset,rLegNormal, lLegx, lLegy, nbSamples, "EFORT", 0.01)
+lLegOffset = [0, 0, 0]
+lLegNormal = [0, 1, 0]
+lLegx = 0.02
+lLegy = 0.02
+fullBody.addLimb(lLegId, lLeg, lfoot, lLegOffset, rLegNormal, lLegx, lLegy, nbSamples, "EFORT", 0.01)
 
 rarmId = 'rhleg'
 rarm = 'rh_haa_joint'
 rHand = 'rh_foot_joint'
-rArmOffset = [0,0,0]
-rArmNormal = [1,0,0]
-rArmx = 0.02; rArmy = 0.02
-fullBody.addLimb(rarmId,rarm,rHand,rArmOffset,rArmNormal, rArmx, rArmy, nbSamples, "EFORT", 0.01)
+rArmOffset = [0, 0, 0]
+rArmNormal = [1, 0, 0]
+rArmx = 0.02
+rArmy = 0.02
+fullBody.addLimb(rarmId, rarm, rHand, rArmOffset, rArmNormal, rArmx, rArmy, nbSamples, "EFORT", 0.01)
 
 larmId = 'lfleg'
 larm = 'lf_haa_joint'
 lHand = 'lf_foot_joint'
-lArmOffset = [0,0,0]
-lArmNormal = [1,0,0]
-lArmx = 0.02; lArmy = 0.02
-fullBody.addLimb(larmId,larm,lHand,lArmOffset,lArmNormal, lArmx, lArmy, nbSamples, "EFORT", 0.01)
+lArmOffset = [0, 0, 0]
+lArmNormal = [1, 0, 0]
+lArmx = 0.02
+lArmy = 0.02
+fullBody.addLimb(larmId, larm, lHand, lArmOffset, lArmNormal, lArmx, lArmy, nbSamples, "EFORT", 0.01)
 
+# make sure this is 0
+q_0 = fullBody.getCurrentConfig()
 
-#make sure this is 0
-q_0 = fullBody.getCurrentConfig ()
 
 def printEffPosition(limbId, nbSamples):
-	limit = nbSamples-1;
-	f1=open('./data/roms/hyq/'+limbId+'.erom', 'w+')
-	for i in range(0,limit):
-		q = fullBody.getSamplePosition(limbId,i)
-		f1.write(str(q[0]) + "," + str(q[1]) + "," + str(q[2]) + "\n")
-	f1.close()
+    limit = nbSamples - 1
+    f1 = open('./data/roms/hyq/' + limbId + '.erom', 'w+')
+    for i in range(0, limit):
+        q = fullBody.getSamplePosition(limbId, i)
+        f1.write(str(q[0]) + "," + str(q[1]) + "," + str(q[2]) + "\n")
+    f1.close()
+
 
 printEffPosition(rarmId, nbSamples)
 printEffPosition(rLegId, nbSamples)
diff --git a/script/hyq_data.py b/script/hyq_data.py
index 90a1a68..e6106a6 100755
--- script/hyq_data.py
+++ script/hyq_data.py
@@ -1,5 +1,5 @@
 from hpp.corbaserver.rbprm.rbprmfullbody import FullBody
-from hpp.corbaserver.rbprm.tools.plot_analytics  import plotOctreeValues
+from hpp.corbaserver.rbprm.tools.plot_analytics import plotOctreeValues
 
 packageName = "hyq_description"
 meshPackageName = "hyq_description"
@@ -11,15 +11,13 @@
 srdfSuffix = ""
 
 #  This time we load the full body model of HyQ
-fullBody = FullBody () 
+fullBody = FullBody()
 fullBody.loadFullBodyModel(urdfName, rootJointType, meshPackageName, packageName, urdfSuffix, srdfSuffix)
-fullBody.setJointBounds ("base_joint_xyz", [-2,5, -1, 1, 0.3, 4])
+fullBody.setJointBounds("base_joint_xyz", [-2, 5, -1, 1, 0.3, 4])
 
 #  Setting a number of sample configurations used
 nbSamples = 50000
 
-
-
 rootName = 'base_joint_xyz'
 
 #  Creating limbs
@@ -32,44 +30,44 @@
 # Last joint of the limb, as in urdf file
 rfFoot = 'rf_foot_joint'
 # Specifying the distance between last joint and contact surface
-offset = [0.,-0.021,0.]
+offset = [0., -0.021, 0.]
 # Specifying the contact surface direction when the limb is in rest pose
-normal = [0,1,0]
+normal = [0, 1, 0]
 # Specifying the rectangular contact surface length
-legx = 0.02; legy = 0.02
+legx = 0.02
+legy = 0.02
 # remaining parameters are the chosen heuristic (here, manipulability), and the resolution of the octree (here, 10 cm).
-fullBody.addLimb(rfLegId,rfLeg,rfFoot,offset,normal, legx, legy, nbSamples, "manipulability", 0.05, cType)
+fullBody.addLimb(rfLegId, rfLeg, rfFoot, offset, normal, legx, legy, nbSamples, "manipulability", 0.05, cType)
 
 lhLegId = 'lhleg'
 lhLeg = 'lh_haa_joint'
 lhFoot = 'lh_foot_joint'
-fullBody.addLimb(lhLegId,lhLeg,lhFoot,offset,normal, legx, legy, nbSamples, "manipulability", 0.05, cType)
+fullBody.addLimb(lhLegId, lhLeg, lhFoot, offset, normal, legx, legy, nbSamples, "manipulability", 0.05, cType)
 
 rhLegId = 'rhleg'
 rhLeg = 'rh_haa_joint'
 rhFoot = 'rh_foot_joint'
-fullBody.addLimb(rhLegId,rhLeg,rhFoot,offset,normal, legx, legy, nbSamples, "manipulability", 0.05, cType)
+fullBody.addLimb(rhLegId, rhLeg, rhFoot, offset, normal, legx, legy, nbSamples, "manipulability", 0.05, cType)
 
 lfLegId = 'lfleg'
 lfLeg = 'lf_haa_joint'
 lfFoot = 'lf_foot_joint'
-fullBody.addLimb(lfLegId,lfLeg,lfFoot,offset,normal, legx, legy, nbSamples, "manipulability", 0.05, cType)
-
+fullBody.addLimb(lfLegId, lfLeg, lfFoot, offset, normal, legx, legy, nbSamples, "manipulability", 0.05, cType)
 
-q_0 = fullBody.getCurrentConfig(); 
+q_0 = fullBody.getCurrentConfig()
 
 
 def runall(lid, dbName):
-	fullBody.runLimbSampleAnalysis(lid, "isotropy", True)
-	fullBody.runLimbSampleAnalysis(lid, "minimumSingularValue", False)
-	#~ fullBody.runLimbSampleAnalysis(lid, "selfCollisionProbability", False)
-	fullBody.runLimbSampleAnalysis(lid, "manipulability", False)
-	fullBody.runLimbSampleAnalysis(lid, "jointLimitsDistance", True)
-	fullBody.saveLimbDatabase(lid, dbName)
-
-runall(rfLegId, './hyq_'+rfLegId+'.db')
-runall(lhLegId, './hyq_'+lhLegId+'.db')
-runall(rhLegId, './hyq_'+rhLegId+'.db')
-runall(lfLegId, './hyq_'+lfLegId+'.db')
-#plotOctreeValues(fullBody, "minimumSingularValue", rarmId)
-
+    fullBody.runLimbSampleAnalysis(lid, "isotropy", True)
+    fullBody.runLimbSampleAnalysis(lid, "minimumSingularValue", False)
+    # fullBody.runLimbSampleAnalysis(lid, "selfCollisionProbability", False)
+    fullBody.runLimbSampleAnalysis(lid, "manipulability", False)
+    fullBody.runLimbSampleAnalysis(lid, "jointLimitsDistance", True)
+    fullBody.saveLimbDatabase(lid, dbName)
+
+
+runall(rfLegId, './hyq_' + rfLegId + '.db')
+runall(lhLegId, './hyq_' + lhLegId + '.db')
+runall(rhLegId, './hyq_' + rhLegId + '.db')
+runall(lfLegId, './hyq_' + lfLegId + '.db')
+# plotOctreeValues(fullBody, "minimumSingularValue", rarmId)
