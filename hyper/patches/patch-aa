Fix a race in pause / resume handling in wait_computation

The invariant running ^ waiting was not respected, and so the code was
possibly wrong. If the method is paused while waiting state (but still
in running before) and then resumed in the same state, the resume part
will call compute, which will call async_wait when it has finished. Two
async_wait on the same time lead to an ECANCELED on the first one, and
so the whole method is aborted.

diff --git a/src/model/compute_wait_expression.cc b/src/model/compute_wait_expression.cc
index 9cf324d..bcdf061 100644
--- src/model/compute_wait_expression.cc
+++ src/model/compute_wait_expression.cc
@@ -52,6 +52,7 @@ namespace hyper {
 				return;
 
 			waiting = true;
+			running = false;
 			deadline_.expires_from_now(delay_);
 			deadline_.async_wait(boost::bind(&compute_wait_expression::handle_timeout, 
 						this,
